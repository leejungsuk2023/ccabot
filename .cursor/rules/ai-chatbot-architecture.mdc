# AI Chatbot Architecture Best Practices

## System Architecture Pattern

### âœ… Recommended Architecture
```
ChannelTalk â†’ GCF Webhook â†’ Gemini AI â†’ Firestore â†’ ChannelTalk
```

### Key Components:
1. **Webhook Receiver**: Firebase Functions v2
2. **AI Processor**: Gemini API with language detection
3. **Data Layer**: Firestore for conversations and settings
4. **Message Sender**: ChannelTalk API with bot profile

## Critical Implementation Patterns

### 1. Message Processing Pipeline
```javascript
// 1. Extract webhook data
const messageEntity = req.body.entity;
const refers = req.body.refers;
const language = messageEntity.language || 'ko';

// 2. Validate and filter messages
if (messageEntity.log || !text || !text.trim()) {
  return res.status(200).send('ignored');
}

// 3. Store in database
await db.collection('conversations').doc(messageId).set({
  userId, userChatId, chatKey,
  sender: personType === 'manager' ? 'human' : 'user',
  text, timestamp: admin.firestore.Timestamp.fromMillis(messageEntity.createdAt)
});

// 4. Process with AI
const aiReply = await generateAIResponse(text, language, userId);

// 5. Send response with delay
await new Promise(resolve => setTimeout(resolve, 25000));
await sendChannelTalkMessage(userChatId, aiReply, botName);
```

### 2. Dynamic Data Integration
```javascript
// Parallel data fetching for performance
const [policyDoc, promotionsDoc, pricingDoc] = await Promise.all([
  db.collection('policyContext').doc('default').get(),
  db.collection('promotions').doc('current').get(),
  db.collection('pricing').doc('products').get()
]);

// Combine into system instruction
const enhancedSystemInstruction = `${policyContext}
í˜„ì¬ í”„ë¡œëª¨ì…˜ ì •ë³´: ${promotionsInfo}
ì œí’ˆ ê°€ê²© ì •ë³´: ${pricingInfo}`;
```

### 3. Error Handling and Safety Nets
```javascript
// AI response safety
if (!aiReply || !aiReply.trim()) {
  aiReply = "ì£„ì†¡í•©ë‹ˆë‹¤. ë‹µë³€ì„ ìƒì„±í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹´ë‹¹ìê°€ í™•ì¸ í›„ ë‹µë³€ë“œë¦¬ê² ìŠµë‹ˆë‹¤.";
}

// Message cleaning for API compatibility
aiReply = aiReply.trim()
  .replace(/\n/g, ' ')
  .replace(/\s+/g, ' ')
  .replace(/"/g, '')
  .replace(/\\/g, '');

// Length limiting
if (aiReply.length > 1000) {
  aiReply = aiReply.substring(0, 997) + "...";
}
```

## Firestore Collection Structure

### Required Collections:
```javascript
// conversations - Chat history
{
  userId: string,
  userChatId: string,
  chatKey: string,
  sender: 'user' | 'ai' | 'human',
  text: string,
  timestamp: Timestamp
}

// sessionModes - User mode management
{
  mode: 'AI_MODE' | 'HUMAN_MODE',
  updatedAt: Date
}

// policyContext - AI behavior guidelines
{
  content: string
}

// promotions - Dynamic promotion data
{
  content: string
}

// pricing - Dynamic pricing data
{
  content: string
}
```

## Performance Optimization

### 1. Memory and Instance Management
```javascript
exports.channelTalkWebhook = https.onRequest({
  region: "asia-northeast3",
  memory: "256Mi",
  maxInstances: 20,
  timeoutSeconds: 60
}, async (req, res) => {
```

### 2. Database Query Optimization
```javascript
// Limit conversation history for performance
const snapshot = await db.collection('conversations')
  .where('userId', '==', userId)
  .orderBy('timestamp', 'desc')
  .limit(15)
  .get();
```

### 3. Parallel Processing
```javascript
// Use Promise.all for concurrent operations
const [conversationHistory, policyData] = await Promise.all([
  getConversationHistory(userId),
  getPolicyContext()
]);
```

## Security and Configuration

### 1. Environment Variables
```javascript
// Development (hardcoded for testing)
const CHANNELTALK_ACCESS_KEY = "your_access_key";
const CHANNELTALK_ACCESS_SECRET = "your_access_secret";
const GEMINI_API_KEY = "your_gemini_key";

// Production (use Firebase Secrets)
exports.channelTalkWebhook = https.onRequest({
  region: "asia-northeast3",
  secrets: ["CHANNELTALK_ACCESS_KEY", "CHANNELTALK_ACCESS_SECRET", "GEMINI_API_KEY"]
}, async (req, res) => {
```

### 2. Input Validation
```javascript
// Validate webhook data
if (!messageEntity || !refers || !refers.userChat) {
  console.log('í•„ìˆ˜ ë°ì´í„°ê°€ ì—†ì–´ ìš”ì²­ì„ ë¬´ì‹œí•©ë‹ˆë‹¤.');
  return res.status(200).send('ignored: missing data');
}

// Validate API keys
if (!CHANNELTALK_ACCESS_KEY || !CHANNELTALK_ACCESS_SECRET) {
  throw new Error('ì±„ë„í†¡ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
}
```

## Monitoring and Debugging

### 1. Comprehensive Logging
```javascript
// Request logging
console.log('ğŸ“¨ [Webhook] ìš”ì²­ ìˆ˜ì‹ ë¨');
console.log('ğŸ” [Webhook] ì±„ë„í†¡ì—ì„œ ë°›ì€ ì–¸ì–´ ì •ë³´:', messageEntity.language);
console.log('ğŸ” [Webhook] ìµœì¢… ì‚¬ìš© ì–¸ì–´:', language);

// AI processing logging
console.log('ğŸ” [AI] Geminiì—ê²Œ ë³´ë‚´ëŠ” ìµœì¢… ìš”ì²­ ë°ì´í„°:', JSON.stringify(geminiRequestBody, null, 2));
console.log('ğŸ“¤ [AI] Geminië¡œë¶€í„° ë°›ì€ ì‘ë‹µ ì „ì²´:', JSON.stringify(geminiResponse.data, null, 2));

// API call logging
console.log('ğŸ” [AI] ì±„ë„í†¡ API ìš”ì²­ ë°ì´í„°:', JSON.stringify(channelTalkPayload, null, 2));
console.log('âœ… [AI] ì±„ë„í†¡ìœ¼ë¡œ ë‹µë³€ ì „ì†¡ ì™„ë£Œ (ë´‡: ${botName})');
```

### 2. Error Tracking
```javascript
try {
  // AI processing
} catch (geminiError) {
  console.error('âŒ [AI] Gemini API í˜¸ì¶œ ì¤‘ ì—ëŸ¬ ë°œìƒ:', geminiError.message);
  aiReply = "ì£„ì†¡í•©ë‹ˆë‹¤. AI ì—”ì§„ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹´ë‹¹ìê°€ ê³§ í™•ì¸í•˜ê² ìŠµë‹ˆë‹¤.";
}

try {
  // ChannelTalk API call
} catch (channelTalkError) {
  console.error('âŒ [AI] ì±„ë„í†¡ API í˜¸ì¶œ ì‹¤íŒ¨:', channelTalkError.response?.data);
  throw channelTalkError;
}
```

## Deployment Checklist

### Pre-deployment:
- [ ] Firebase Functions v2 syntax verified
- [ ] All API keys configured
- [ ] ChannelTalk bot profile created
- [ ] Firestore collections initialized
- [ ] Error handling implemented
- [ ] Logging system in place

### Post-deployment:
- [ ] Webhook URL configured in ChannelTalk
- [ ] Test messages sent and received
- [ ] AI responses working correctly
- [ ] Language detection functioning
- [ ] Error logs monitored
- [ ] Performance metrics checked

## Common Anti-patterns to Avoid

### âŒ Don't:
- Use Firebase Functions v1 syntax
- Skip botName parameter in ChannelTalk API
- Use weak language instructions
- Store sensitive data in code
- Ignore error handling
- Skip message cleaning
- Use synchronous operations where async is needed

### âœ… Do:
- Use Firebase Functions v2 syntax
- Include botName in ChannelTalk API calls
- Implement strong language enforcement
- Use environment variables for secrets
- Implement comprehensive error handling
- Clean and validate all messages
- Use Promise.all for parallel operations
description:
globs:
alwaysApply: false
---
